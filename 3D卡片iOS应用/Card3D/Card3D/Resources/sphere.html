<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>3D Sphere</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #111111;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    #canvas-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const container = document.getElementById('canvas-container');

    // Scene setup
    const scene = new THREE.Scene();

    // Use full viewport dimensions
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    camera.position.z = 3.5;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      premultipliedAlpha: true,
      powerPreference: "high-performance"
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance
    renderer.setClearColor(0x000000, 0);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);

    // Sphere geometry
    const geometry = new THREE.SphereGeometry(1.8, 128, 128);

    // Custom shader material
    const vertexShader = `
      uniform float time;
      uniform float distortionIntensity;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;

      float noise(vec3 p) {
        return sin(p.x * 1.5 + time * 0.5) * sin(p.y * 1.5 + time * 0.4) * sin(p.z * 1.5 + time * 0.6);
      }

      void main() {
        vNormal = normalize(normalMatrix * normal);
        vPosition = position;
        vUv = uv;

        vec3 pos = position;

        float wave1 = sin(position.x * 4.5 + time * 0.8) * cos(position.y * 4.5 + time * 0.6);
        float wave2 = cos(position.z * 5.0 + time * 0.7) * sin(position.x * 4.2 - time * 0.5);
        float wave3 = sin(position.y * 4.8 - time * 0.9) * cos(position.z * 4.6 + time * 0.6);

        float combinedWave = (wave1 * 0.4 + wave2 * 0.3 + wave3 * 0.3);
        float smoothNoise = noise(position * 2.5) * 0.3;

        pos += normal * combinedWave * distortionIntensity * 0.2;
        pos += normal * smoothNoise * distortionIntensity * 0.15;

        vec4 worldPos = modelMatrix * vec4(pos, 1.0);
        vWorldPosition = worldPos.xyz;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    const fragmentShader = `
      uniform vec3 color1;
      uniform vec3 color2;
      uniform vec3 color3;
      uniform float time;
      uniform float glowIntensity;
      uniform float glassiness;
      uniform float refractiveIndex;

      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vWorldPosition;
      varying vec2 vUv;

      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        vec3 i  = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;

        i = mod289(i);
        vec4 p = permute(permute(permute(
                 i.z + vec4(0.0, i1.z, i2.z, 1.0))
               + i.y + vec4(0.0, i1.y, i2.y, 1.0))
               + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);

        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      void main() {
        vec3 normalizedNormal = normalize(vNormal);
        vec3 normalizedPos = normalize(vPosition);

        vec3 noisePos = normalizedPos * 0.5;

        float n1 = snoise(noisePos * 0.8 + vec3(time * 0.6, 0.0, 0.0)) * 0.3;
        float n2 = snoise(noisePos * 0.6 + vec3(0.0, time * 0.5, 0.0)) * 0.3;
        float n3 = snoise(noisePos * 0.7 + vec3(0.0, 0.0, time * 0.55)) * 0.3;

        float w1 = 0.5 + 0.5 * sin(normalizedPos.x * 1.5 + normalizedPos.y * 0.8 + n1 + time * 2.0);
        float w2 = 0.5 + 0.5 * sin(normalizedPos.y * 1.2 + normalizedPos.z * 0.6 + n2 - time * 1.5);

        w1 = smoothstep(0.3, 0.7, w1);
        w2 = 1.0 - w1;

        vec3 finalColor = mix(color1, color2, w2);

        vec3 gradientBase = mix(
          color1,
          color2,
          (normalizedPos.x + 1.0) * 0.5 + sin(time * 0.8) * 0.1
        );

        float blendNoise = snoise(noisePos * 0.5 + time * 0.3) * 0.15 + 0.5;
        finalColor = mix(finalColor, gradientBase, blendNoise * 0.3);

        vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
        float fresnel = pow(1.0 - abs(dot(normalizedNormal, viewDirection)), refractiveIndex);

        float glassReflection = fresnel * glassiness;

        vec3 refractedColor = finalColor;
        refractedColor = mix(refractedColor, vec3(1.0), glassReflection * 0.3);

        vec3 glowColor = finalColor * 1.5;
        finalColor = mix(refractedColor, glowColor, 0.25);

        vec3 edgeGlow = mix(finalColor * 2.0, vec3(1.0), 0.5);
        finalColor = mix(finalColor, edgeGlow, fresnel * 0.7);

        vec3 lightDir = normalize(vec3(-0.7, 0.7, 0.5));
        vec3 halfVector = normalize(lightDir + viewDirection);
        float specular = pow(max(dot(normalizedNormal, halfVector), 0.0), 32.0);
        specular = smoothstep(0.0, 1.0, specular);
        finalColor += vec3(1.0) * specular * 0.1 * glassiness;

        finalColor *= 1.0 + 0.15 * normalizedNormal.y;
        finalColor *= glowIntensity;
        finalColor = max(finalColor, vec3(0.12, 0.11, 0.09));

        float alpha = 0.98 + fresnel * 0.02;
        finalColor = clamp(finalColor, 0.0, 1.0);

        gl_FragColor = vec4(finalColor, alpha);
      }
    `;

    const material = new THREE.ShaderMaterial({
      uniforms: {
        color1: { value: new THREE.Color('#FFF68D') },
        color2: { value: new THREE.Color('#3878D2') },
        color3: { value: new THREE.Color('#FFF68D') },
        time: { value: 0 },
        glowIntensity: { value: 1.2 },
        glassiness: { value: 0.8 },
        refractiveIndex: { value: 1.5 },
        distortionIntensity: { value: 0 }
      },
      vertexShader,
      fragmentShader,
      side: THREE.FrontSide,
      wireframe: false,
      flatShading: false,
      transparent: true,
      depthWrite: true,
      depthTest: true
    });

    // Create mesh
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
    directionalLight.position.set(-5, 5, 5);
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0xffffff, 0.3, 10);
    pointLight.position.set(0, 0, 3);
    scene.add(pointLight);

    // OrbitControls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enableZoom = true;
    controls.minDistance = 1.5;
    controls.maxDistance = 10;

    // Track interaction state
    let isInteracting = false;

    const handleInteractionStart = () => {
      isInteracting = true;
    };

    const handleInteractionEnd = () => {
      isInteracting = false;
    };

    renderer.domElement.addEventListener('mousedown', handleInteractionStart);
    renderer.domElement.addEventListener('touchstart', handleInteractionStart, { passive: true });
    renderer.domElement.addEventListener('mouseup', handleInteractionEnd);
    renderer.domElement.addEventListener('mouseleave', handleInteractionEnd);
    renderer.domElement.addEventListener('touchend', handleInteractionEnd);

    // Animation loop
    let frameCount = 0;
    function animate() {
      requestAnimationFrame(animate);
      frameCount++;

      const t = performance.now() * 0.001;
      material.uniforms.time.value = t;

      if (frameCount < 10) {
        material.needsUpdate = true;
      }

      material.uniforms.glowIntensity.value = 1.2 + Math.sin(t * 2) * 0.1;
      material.uniforms.glassiness.value = 0.8 + Math.sin(t * 1.5) * 0.1;

      if (isInteracting) {
        material.uniforms.distortionIntensity.value = 0.65 + Math.sin(t * 0.8) * 0.05;
      } else {
        material.uniforms.distortionIntensity.value = 0;
      }

      sphere.rotation.y += 0.008 + Math.sin(t * 2) * 0.003;
      sphere.rotation.x += 0.004 + Math.cos(t * 1.5) * 0.002;
      sphere.rotation.z = Math.sin(t * 0.5) * 0.1;

      sphere.position.y = Math.sin(t * 2) * 0.05;
      sphere.position.x = Math.cos(t * 1.5) * 0.03;

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;

      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(newWidth, newHeight);
    });
  </script>
</body>
</html>
