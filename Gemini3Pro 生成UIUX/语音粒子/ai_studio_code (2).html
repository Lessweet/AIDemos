<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Voice Interface - Strict Feedback</title>
    <style>
        :root {
            --gold-color: #b48c50;
            --bg-color: #ffffff;
            --text-color: #333333;
            --btn-bg: #f2f2f2;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overscroll-behavior: none;
        }

        .phone-container {
            width: 375px;
            height: 812px;
            background-color: var(--bg-color);
            border-radius: 40px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* 顶部栏 */
        .status-bar {
            height: 44px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            font-size: 15px;
            font-weight: 600;
            z-index: 10;
            user-select: none;
        }

        .dynamic-island {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 35px;
            background-color: black;
            border-radius: 20px;
            z-index: 11;
        }

        .status-icons { display: flex; gap: 6px; }

        .settings-icon {
            position: absolute;
            top: 60px;
            right: 24px;
            color: #666;
            cursor: pointer;
            z-index: 10;
        }

        /* 画布区域 */
        .canvas-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: flex-end; /* 底部对齐，为了放字幕 */
            position: relative;
            padding-bottom: 30px;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            z-index: 1;
        }

        /* 字幕显示区域 */
        .transcript-container {
            position: relative;
            z-index: 5;
            width: 84%;
            min-height: 80px; /* 预留高度防止跳动 */
            text-align: center;
            margin-bottom: 30px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }

        .transcript-text {
            font-size: 20px;
            font-weight: 500;
            color: #111;
            line-height: 1.5;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.5s ease, transform 0.5s ease;
            text-shadow: 0 2px 10px rgba(255,255,255,0.8);
        }

        .transcript-text.active {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* 状态指示器：表明是谁在说话 */
        .state-indicator {
            font-size: 12px;
            color: #999;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .state-indicator.show { opacity: 1; }

        /* 底部栏 */
        .bottom-bar {
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 40px 20px 40px;
            box-sizing: border-box;
            user-select: none;
            z-index: 10;
        }

        .btn-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: var(--btn-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn-circle:active {
            background-color: #d0d0d0;
            transform: scale(0.95);
        }
    </style>
</head>
<body>

    <div class="phone-container">
        <div class="dynamic-island"></div>

        <div class="status-bar">
            <span id="clock">23:11</span>
            <div class="status-icons">
                <svg width="18" height="12" viewBox="0 0 18 12" fill="black"><path d="M1 10h3v-2H1v2zm5 0h3V5H6v5zm5 0h3V2h-3v8zm5 0h3V0h-3v10z"/></svg>
                <svg width="18" height="12" viewBox="0 0 18 12" fill="black"><path d="M9 11l-8-9h16l-8 9z"/></svg>
                <svg width="22" height="12" viewBox="0 0 25 12" fill="none"><rect x="0.5" y="0.5" width="20" height="10" rx="2.5" stroke="black"/><rect x="2" y="2" width="17" height="7" rx="1.5" fill="black"/><path d="M23 4v4" stroke="black" stroke-linecap="round"/></svg>
            </div>
        </div>

        <div class="settings-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
        </div>

        <div class="canvas-wrapper" id="canvas-container">
            <canvas id="particleCanvas"></canvas>
            
            <div class="transcript-container">
                <div class="state-indicator" id="state-text">AI 正在说话</div>
                <div class="transcript-text" id="transcript"></div>
            </div>
        </div>

        <div class="bottom-bar">
            <div class="btn-circle">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </div>
            
            <div class="btn-circle">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
            </div>
        </div>
    </div>

    <script>
        // --- 1. 基础 UI 逻辑 ---
        function updateTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            document.getElementById('clock').innerText = `${hours}:${minutes}`;
        }
        setInterval(updateTime, 1000);
        updateTime();

        // --- 2. 模拟对话控制系统 ---
        const systemState = {
            speaker: 'idle', // 'ai', 'user', 'idle'
            audioLevel: 0,   // 当前模拟的音量
            smoothedLevel: 0 // 平滑后的音量（用于动画）
        };

        const transcriptEl = document.getElementById('transcript');
        const stateEl = document.getElementById('state-text');

        // 对话剧本
        const script = [
            { speaker: 'ai', text: "晚上好，请问有什么可以帮您？", duration: 3000 },
            { speaker: 'user', text: "（用户正在说话...）", duration: 2000 },
            { speaker: 'ai', text: "正在为您规划去往机场的路线。", duration: 3000 },
            { speaker: 'user', text: "（用户正在思考...）", duration: 1500 },
            { speaker: 'ai', text: "预计路程需要45分钟，现在的路况良好。", duration: 3500 },
            { speaker: 'idle', text: "", duration: 2000 }
        ];

        let scriptIndex = 0;

        // 核心：处理对话流程
        function playScript() {
            const scene = script[scriptIndex];
            systemState.speaker = scene.speaker;

            // 更新 UI 文本
            if (scene.speaker === 'ai') {
                transcriptEl.innerText = ""; // 清空上一句
                stateEl.innerText = "SIRI";
                stateEl.classList.add('show');
                typeWriter(scene.text, scene.duration);
            } else if (scene.speaker === 'user') {
                transcriptEl.innerText = "聆听中...";
                stateEl.classList.remove('show'); // 隐藏 AI 标签
                transcriptEl.classList.add('active');
                
                // 用户说话时，AI 球体应该安静，所以这里不产生 audioLevel
                setTimeout(nextScene, scene.duration);
            } else {
                // Idle
                transcriptEl.classList.remove('active');
                stateEl.classList.remove('show');
                setTimeout(nextScene, scene.duration);
            }
        }

        // 打字机效果 (仅用于 AI 说话)
        function typeWriter(text, duration) {
            transcriptEl.classList.add('active');
            let charIndex = 0;
            const speed = duration / text.length; // 根据总时长计算打字速度

            const interval = setInterval(() => {
                if (charIndex < text.length) {
                    transcriptEl.innerText += text.charAt(charIndex);
                    charIndex++;
                } else {
                    clearInterval(interval);
                    setTimeout(nextScene, 1000); // 读完后停顿一秒
                }
            }, speed);
        }

        function nextScene() {
            scriptIndex = (scriptIndex + 1) % script.length;
            playScript();
        }

        // 模拟 AI 的声波震动
        function updateAudioSimulation() {
            if (systemState.speaker === 'ai') {
                // 只有 AI 说话时，才生成随机音量波形
                // 模拟语流：正弦波 + 随机噪点
                const time = Date.now() / 100;
                const wave = (Math.sin(time) + 1) / 2; // 0-1
                const jitter = Math.random() * 0.3;
                systemState.audioLevel = wave * 0.6 + jitter;
            } else {
                // 用户说话或空闲时，音量迅速归零
                systemState.audioLevel = 0;
            }

            // 平滑处理
            systemState.smoothedLevel += (systemState.audioLevel - systemState.smoothedLevel) * 0.1;
            
            requestAnimationFrame(updateAudioSimulation);
        }

        // 启动系统
        updateAudioSimulation();
        setTimeout(playScript, 1000);


        // --- 3. 粒子视觉引擎 ---
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        
        let width, height;
        const particleCount = 850; 
        const baseRadius = 130; 
        let angleX = 0;
        let angleY = 0;

        const mouse = { x: -9999, y: -9999, active: false };
        const particles = [];

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width * 2; 
            canvas.height = height * 2;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(2, 2);
        }

        // 交互：风力效果（始终有效，不分 AI/User）
        function updateMouse(x, y) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = x - rect.left;
            mouse.y = y - rect.top;
            mouse.active = true;
        }

        container.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY));
        container.addEventListener('mouseleave', () => { mouse.active = false; });
        container.addEventListener('touchmove', e => { e.preventDefault(); updateMouse(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        container.addEventListener('touchstart', e => updateMouse(e.touches[0].clientX, e.touches[0].clientY), { passive: false });
        container.addEventListener('touchend', () => { mouse.active = false; });

        function initParticles() {
            const phi = Math.PI * (3 - Math.sqrt(5)); 
            for (let i = 0; i < particleCount; i++) {
                const y = 1 - (i / (particleCount - 1)) * 2; 
                const r = Math.sqrt(1 - y * y); 
                const theta = phi * i; 
                
                const x = Math.cos(theta) * r;
                const z = Math.sin(theta) * r;

                particles.push({
                    baseX: x * baseRadius,
                    baseY: y * baseRadius,
                    baseZ: z * baseRadius,
                    dx: 0, dy: 0, dz: 0,
                    vx: 0, vy: 0, vz: 0,
                    friction: 0.94 + Math.random() * 0.02,
                    returnSpeed: 0.01 + Math.random() * 0.01
                });
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // 获取当前的音频反馈强度 (0.0 - 1.0)
            // 关键点：只有 AI 说话时，smoothedLevel 才有值
            const feedback = systemState.smoothedLevel;

            // 1. 旋转控制
            // 基础慢速 + 音频加速
            // 当反馈为0时，angleX 增量为 0.0015 (慢速)
            // 当反馈高时，加速旋转
            angleX += 0.0015 + (feedback * 0.02);
            angleY += 0.0025 + (feedback * 0.02);

            const cx = width / 2;
            const cy = height / 2 - 40; 
            const fov = 400; 

            // 2. 呼吸半径控制
            // 只有 AI 说话时，球体才会根据音量变大
            const radiusScale = 1 + (feedback * 0.25); 

            particles.forEach(p => {
                // 计算球体基础旋转位置 (应用呼吸缩放)
                const sx = p.baseX * radiusScale;
                const sy = p.baseY * radiusScale;
                const sz = p.baseZ * radiusScale;

                let xRot = sx * Math.cos(angleY) - sz * Math.sin(angleY);
                let z1 = sz * Math.cos(angleY) + sx * Math.sin(angleY);
                let yRot = sy * Math.cos(angleX) - z1 * Math.sin(angleX);
                let zRot = z1 * Math.cos(angleX) + sy * Math.sin(angleX);

                // 3. 震动反馈 (Audio Jitter)
                // 只有 AI 说话时，粒子才会微微抖动
                if (feedback > 0.05) {
                    const jitterAmount = feedback * 3; 
                    xRot += (Math.random() - 0.5) * jitterAmount;
                    yRot += (Math.random() - 0.5) * jitterAmount;
                    zRot += (Math.random() - 0.5) * jitterAmount;
                }

                // 4. 交互物理 (风力飞散) - 独立于语音状态
                const tempScale = fov / (fov + zRot);
                const screenX = (xRot + p.dx) * tempScale + cx;
                const screenY = (yRot + p.dy) * tempScale + cy;

                if (mouse.active) {
                    const dx = screenX - mouse.x;
                    const dy = screenY - mouse.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const interactRadius = 140;

                    if (dist < interactRadius) {
                        const force = (interactRadius - dist) / interactRadius;
                        const angle = Math.atan2(dy, dx);
                        const push = 3.5;
                        p.vx += Math.cos(angle) * force * push;
                        p.vy += Math.sin(angle) * force * push;
                        p.vz += (Math.random() - 0.5) * force * push * 2;
                    }
                }

                // 物理惯性更新
                p.vx *= p.friction;
                p.vy *= p.friction;
                p.vz *= p.friction;

                p.vx -= p.dx * p.returnSpeed;
                p.vy -= p.dy * p.returnSpeed;
                p.vz -= p.dz * p.returnSpeed;

                p.dx += p.vx;
                p.dy += p.vy;
                p.dz += p.vz;

                // 最终位置
                const finalX = xRot + p.dx;
                const finalY = yRot + p.dy;
                const finalZ = zRot + p.dz;

                const scale = fov / (fov + finalZ);
                const x2d = finalX * scale + cx;
                const y2d = finalY * scale + cy;

                // 颜色与透明度
                let alpha = (scale - 0.4) * 1.5;
                const disp = Math.sqrt(p.dx**2 + p.dy**2 + p.dz**2);
                
                // 飞散变淡
                if(disp > 50) alpha *= Math.max(0.3, 1 - disp / 300);

                // 说话时高亮：只有 feedback > 0 时才变亮
                alpha += feedback * 0.3; 

                const size = scale * 1.3;

                if (alpha > 0) {
                    ctx.fillStyle = `rgba(197, 160, 101, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', resize);
        resize();
        initParticles();
        animate();

    </script>
</body>
</html>