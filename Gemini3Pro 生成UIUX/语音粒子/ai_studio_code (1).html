<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Voice Interface - Audio Reactive</title>
    <style>
        :root {
            --gold-color: #b48c50;
            --bg-color: #ffffff;
            --text-color: #333333;
            --btn-bg: #f2f2f2;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overscroll-behavior: none;
        }

        .phone-container {
            width: 375px;
            height: 812px;
            background-color: var(--bg-color);
            border-radius: 40px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .status-bar {
            height: 44px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            font-size: 15px;
            font-weight: 600;
            z-index: 10;
            user-select: none;
        }

        .dynamic-island {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 35px;
            background-color: black;
            border-radius: 20px;
            z-index: 11;
        }

        .status-icons {
            display: flex;
            gap: 6px;
        }

        .settings-icon {
            position: absolute;
            top: 60px;
            right: 24px;
            color: #666;
            cursor: pointer;
            z-index: 10;
        }

        /* 画布区域 */
        .canvas-wrapper {
            flex: 1; /* 占据剩余空间 */
            display: flex;
            justify-content: center;
            align-items: flex-end; /* 底部对齐，为了放字幕 */
            position: relative;
            padding-bottom: 20px; /* 给字幕留位置 */
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            z-index: 1;
        }

        /* 字幕显示区域 */
        .transcript-container {
            position: relative;
            z-index: 5;
            width: 80%;
            min-height: 60px;
            text-align: center;
            margin-bottom: 40px;
            pointer-events: none; /* 让点击穿透到 Canvas */
        }

        .transcript-text {
            font-size: 20px;
            font-weight: 500;
            color: #111;
            line-height: 1.4;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .transcript-text.active {
            opacity: 1;
            transform: translateY(0);
        }

        .bottom-bar {
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 40px 20px 40px;
            box-sizing: border-box;
            user-select: none;
            z-index: 10;
            background: linear-gradient(to top, #fff 20%, transparent); /* 稍微遮挡 */
        }

        .btn-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: var(--btn-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .btn-circle:active {
            background-color: #d0d0d0;
            transform: scale(0.95);
        }

        .btn-active {
            background-color: #333 !important;
        }
        .btn-active svg {
            stroke: #fff !important;
        }

        .prompt-text {
            color: #666;
            font-size: 16px;
            font-weight: 500;
        }
    </style>
</head>
<body>

    <div class="phone-container">
        <div class="dynamic-island"></div>

        <div class="status-bar">
            <span id="clock">23:11</span>
            <div class="status-icons">
                <svg width="18" height="12" viewBox="0 0 18 12" fill="black"><path d="M1 10h3v-2H1v2zm5 0h3V5H6v5zm5 0h3V2h-3v8zm5 0h3V0h-3v10z"/></svg>
                <svg width="18" height="12" viewBox="0 0 18 12" fill="black"><path d="M9 11l-8-9h16l-8 9z"/></svg>
                <svg width="22" height="12" viewBox="0 0 25 12" fill="none"><rect x="0.5" y="0.5" width="20" height="10" rx="2.5" stroke="black"/><rect x="2" y="2" width="17" height="7" rx="1.5" fill="black"/><path d="M23 4v4" stroke="black" stroke-linecap="round"/></svg>
            </div>
        </div>

        <div class="settings-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
        </div>

        <!-- Canvas 和 字幕的容器 -->
        <div class="canvas-wrapper" id="canvas-container">
            <canvas id="particleCanvas"></canvas>
            
            <!-- 动态字幕 -->
            <div class="transcript-container">
                <div class="transcript-text" id="transcript"></div>
            </div>
        </div>

        <div class="bottom-bar">
            <div class="btn-circle">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </div>
            
            <!-- 麦克风按钮 -->
            <div class="btn-circle" id="mic-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
            </div>
        </div>
    </div>

    <script>
        // 1. 基础 UI 逻辑
        function updateTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            document.getElementById('clock').innerText = `${hours}:${minutes}`;
        }
        setInterval(updateTime, 1000);
        updateTime();

        // 2. 音频模拟控制器 (Audio Controller)
        const audioState = {
            level: 0,        // 当前瞬间音量 (0.0 - 1.0)
            smoothed: 0,     // 平滑后的音量，用于动画
            isSpeaking: false, // 是否正在说话
            mode: 'simulated' // 'simulated' or 'real'
        };

        // 模拟对话文本队列
        const dialogueQueue = [
            "你好，请问今天天气怎么样？",
            "正在为您查询...",
            "今天天气晴朗，气温24度。",
            "需要我为您播放点音乐吗？",
            "好的，播放推荐列表。"
        ];
        let dialogueIndex = 0;
        let charIndex = 0;
        const transcriptEl = document.getElementById('transcript');

        // 模拟语音波形生成器
        function simulateVoice() {
            if (audioState.mode !== 'simulated') return;

            const now = Date.now();
            // 使用正弦波叠加噪声来模拟说话的音量起伏
            if (audioState.isSpeaking) {
                // 生成 0.3 ~ 0.8 之间的波动，偶尔停顿
                const wave = Math.sin(now / 150) * 0.3 + 0.4;
                const noise = Math.random() * 0.2;
                audioState.level = Math.max(0, wave + noise);
            } else {
                audioState.level = Math.max(0, audioState.level * 0.9); // 快速衰减
            }
        }

        // 文本打字机效果
        function typeWriter() {
            if (!audioState.isSpeaking && dialogueIndex < dialogueQueue.length) {
                // 开始一句新话
                audioState.isSpeaking = true;
                transcriptEl.innerText = "";
                transcriptEl.classList.add('active');
                charIndex = 0;
                
                const currentText = dialogueQueue[dialogueIndex];
                
                const typeInterval = setInterval(() => {
                    if (charIndex < currentText.length) {
                        transcriptEl.innerText += currentText.charAt(charIndex);
                        charIndex++;
                    } else {
                        // 这句话说完了
                        clearInterval(typeInterval);
                        setTimeout(() => {
                            audioState.isSpeaking = false; // 停止说话（音量归零）
                            setTimeout(() => {
                                // 停顿后准备下一句
                                if(dialogueIndex < dialogueQueue.length - 1) {
                                     dialogueIndex++;
                                     typeWriter();
                                } else {
                                    // 循环演示
                                    dialogueIndex = 0;
                                    typeWriter();
                                }
                            }, 1500); // 句间停顿
                        }, 500); // 句尾停顿
                    }
                }, 100 + Math.random() * 50); // 打字速度随机，模拟语速
            }
        }

        // 启动模拟对话
        setTimeout(typeWriter, 1000);
        setInterval(simulateVoice, 50);


        // 3. 粒子动画逻辑 (集成音频反馈)
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        
        let width, height;
        const particleCount = 850; 
        const baseRadius = 130; 
        let angleX = 0;
        let angleY = 0;

        const mouse = { x: -9999, y: -9999, active: false };
        const particles = [];

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width * 2; 
            canvas.height = height * 2;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(2, 2);
        }

        // 交互逻辑
        function updateMouse(x, y) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = x - rect.left;
            mouse.y = y - rect.top;
            mouse.active = true;
        }

        container.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY));
        container.addEventListener('mouseleave', () => { mouse.active = false; });
        container.addEventListener('touchmove', e => { e.preventDefault(); updateMouse(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        container.addEventListener('touchstart', e => updateMouse(e.touches[0].clientX, e.touches[0].clientY), { passive: false });
        container.addEventListener('touchend', () => { mouse.active = false; });

        function initParticles() {
            const phi = Math.PI * (3 - Math.sqrt(5)); 
            for (let i = 0; i < particleCount; i++) {
                const y = 1 - (i / (particleCount - 1)) * 2; 
                const r = Math.sqrt(1 - y * y); 
                const theta = phi * i; 
                const x = Math.cos(theta) * r;
                const z = Math.sin(theta) * r;

                particles.push({
                    baseX: x * baseRadius,
                    baseY: y * baseRadius,
                    baseZ: z * baseRadius,
                    dx: 0, dy: 0, dz: 0,
                    vx: 0, vy: 0, vz: 0,
                    friction: 0.94 + Math.random() * 0.02,
                    returnSpeed: 0.01 + Math.random() * 0.01
                });
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // A. 音量平滑处理 (Lerp)
            // 将瞬间音量平滑过渡，避免动画跳跃
            audioState.smoothed += (audioState.level - audioState.smoothed) * 0.1;

            // B. 动态调整参数 based on Audio
            // 1. 旋转速度：声音越大，转得越快
            const rotationBoost = audioState.smoothed * 0.02;
            angleX += 0.0015 + rotationBoost;
            angleY += 0.0025 + rotationBoost;

            // 2. 呼吸半径：声音越大，球体越大
            const currentRadiusScale = 1 + audioState.smoothed * 0.3; // 最大放大 30%

            const cx = width / 2;
            // 将中心点向上移一点，给文字腾位置
            const cy = height / 2 - 40; 
            const fov = 400; 

            particles.forEach(p => {
                // 1. 基础旋转 + 2. 音频膨胀 (应用 Scale)
                const scaleR = currentRadiusScale;

                let xRot = (p.baseX * scaleR) * Math.cos(angleY) - (p.baseZ * scaleR) * Math.sin(angleY);
                let z1 = (p.baseZ * scaleR) * Math.cos(angleY) + (p.baseX * scaleR) * Math.sin(angleY);
                let yRot = (p.baseY * scaleR) * Math.cos(angleX) - z1 * Math.sin(angleX);
                let zRot = z1 * Math.cos(angleX) + (p.baseY * scaleR) * Math.sin(angleX);

                // 3. 音频震动 (Jitter)
                // 在高音量时增加随机抖动
                if (audioState.smoothed > 0.1) {
                    xRot += (Math.random() - 0.5) * audioState.smoothed * 4;
                    yRot += (Math.random() - 0.5) * audioState.smoothed * 4;
                }

                // 4. 交互物理 (风力)
                const tempScale = fov / (fov + zRot);
                const screenX = (xRot + p.dx) * tempScale + cx;
                const screenY = (yRot + p.dy) * tempScale + cy;

                if (mouse.active) {
                    const dx = screenX - mouse.x;
                    const dy = screenY - mouse.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const interactRadius = 140;

                    if (dist < interactRadius) {
                        const force = (interactRadius - dist) / interactRadius;
                        const angle = Math.atan2(dy, dx);
                        const push = 3.5;
                        p.vx += Math.cos(angle) * force * push;
                        p.vy += Math.sin(angle) * force * push;
                        p.vz += (Math.random() - 0.5) * force * push * 2;
                    }
                }

                p.vx *= p.friction;
                p.vy *= p.friction;
                p.vz *= p.friction;

                p.vx -= p.dx * p.returnSpeed;
                p.vy -= p.dy * p.returnSpeed;
                p.vz -= p.dz * p.returnSpeed;

                p.dx += p.vx;
                p.dy += p.vy;
                p.dz += p.vz;

                const finalX = xRot + p.dx;
                const finalY = yRot + p.dy;
                const finalZ = zRot + p.dz;

                const scale = fov / (fov + finalZ);
                const x2d = finalX * scale + cx;
                const y2d = finalY * scale + cy;

                let alpha = (scale - 0.4) * 1.5;
                const disp = Math.sqrt(p.dx**2 + p.dy**2 + p.dz**2);
                if(disp > 50) alpha *= Math.max(0.3, 1 - disp / 300);

                // 音频高亮：声音越大，粒子越亮/越不透明
                alpha += audioState.smoothed * 0.2; 

                const size = scale * 1.3;

                if (alpha > 0) {
                    ctx.fillStyle = `rgba(197, 160, 101, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            requestAnimationFrame(animate);
        }

        // 真实麦克风接入 (可选)
        const micBtn = document.getElementById('mic-btn');
        micBtn.addEventListener('click', async () => {
            if (audioState.mode === 'real') return;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(stream);
                const analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                source.connect(analyser);

                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                audioState.mode = 'real';
                micBtn.classList.add('btn-active'); // 视觉反馈

                // 停止模拟打字机
                audioState.isSpeaking = false; 
                transcriptEl.innerText = "正在聆听...";

                // 实时更新音量函数
                const updateRealAudio = () => {
                    analyser.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
                    const avg = sum / dataArray.length;
                    // 归一化音量 0.0 - 1.0
                    audioState.level = Math.min(1, avg / 100);
                    requestAnimationFrame(updateRealAudio);
                };
                updateRealAudio();

            } catch (err) {
                console.error("无法获取麦克风权限", err);
                alert("无法访问麦克风，将继续使用模拟模式。");
            }
        });

        window.addEventListener('resize', resize);
        resize();
        initParticles();
        animate();

    </script>
</body>
</html>