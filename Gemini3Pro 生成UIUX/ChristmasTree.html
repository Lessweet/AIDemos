<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D Interactive Christmas Tree (Final Fix)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
            font-family: 'Arial', sans-serif;
            user-select: none;
        }
        
        #canvas-container {
            width: 100%;
            height: 100vh;
            display: block;
        }

        #ui-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 50px;
            display: flex;
            gap: 20px;
            border: 1px solid rgba(255,255,255,0.3);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 100; /* ç¡®ä¿UIåœ¨æœ€ä¸Šå±‚ */
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            background: rgba(255,255,255,0.2);
        }

        .tool-btn:hover {
            transform: scale(1.1);
            background: rgba(255,255,255,0.4);
        }

        .tool-btn.active {
            border-color: #fff;
            background: rgba(255,255,255,0.6);
            box-shadow: 0 0 15px #fff;
        }

        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
        h1 { margin: 0; font-weight: 300; letter-spacing: 2px; }
        p { font-size: 14px; opacity: 0.8; }
    </style>
</head>
<body>

    <div id="instructions">
        <h1>3D Christmas Tree</h1>
        <p>æ‹–æ‹½æ—‹è½¬è§†è§’ â€¢ ç‚¹å‡»æ ‘å¶æ·»åŠ è£…é¥°</p>
    </div>

    <div id="ui-panel">
        <div class="tool-btn active" onclick="selectTool('ball', this)" title="çº¢å½©çƒ">ğŸ”´</div>
        <div class="tool-btn" onclick="selectTool('gold', this)" title="é‡‘é“ƒé“›">ğŸ””</div>
        <div class="tool-btn" onclick="selectTool('light', this)" title="å‘å…‰ç¯">ğŸ’¡</div>
        <div class="tool-btn" onclick="clearDecorations()" title="æ¸…é™¤æ‰€æœ‰">ğŸ—‘ï¸</div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let treeGroup;
        let decorations = [];
        let raycaster;
        
        // äº¤äº’ç›¸å…³å˜é‡
        let currentTool = 'ball';
        let mouseDownPosition = new THREE.Vector2();
        let mouseUpPosition = new THREE.Vector2();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x2c5364, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 60);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // ä¸»å…‰æº
            const dirLight = new THREE.DirectionalLight(0xffeebb, 0.8);
            dirLight.position.set(20, 50, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // æ ‘å†…éƒ¨æš–å…‰
            const innerLight = new THREE.PointLight(0xffaa00, 0.5, 50);
            innerLight.position.set(0, 10, 0);
            scene.add(innerLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 100;

            createGround();
            createTree(); // ç¡®ä¿è¿™é‡Œåˆ›å»ºäº†æ ‘
            createSnow();

            raycaster = new THREE.Raycaster();

            window.addEventListener('resize', onWindowResize);
            
            // --- æ ¸å¿ƒä¿®å¤ï¼šæ”¹ç”¨åæ ‡å·®å€¼åˆ¤æ–­ç‚¹å‡» ---
            // 1. é¼ æ ‡æŒ‰ä¸‹æ—¶ï¼Œè®°å½•ä½ç½®
            renderer.domElement.addEventListener('pointerdown', (event) => {
                mouseDownPosition.x = event.clientX;
                mouseDownPosition.y = event.clientY;
            });

            // 2. é¼ æ ‡æŠ¬èµ·æ—¶ï¼Œè®°å½•ä½ç½®å¹¶åˆ¤æ–­
            renderer.domElement.addEventListener('pointerup', (event) => {
                mouseUpPosition.x = event.clientX;
                mouseUpPosition.y = event.clientY;

                // è®¡ç®—ç§»åŠ¨è·ç¦»
                const distance = mouseDownPosition.distanceTo(mouseUpPosition);

                // å¦‚æœç§»åŠ¨è·ç¦»å°äº 5 åƒç´ ï¼Œåˆ™è§†ä¸ºâ€œç‚¹å‡»â€ï¼Œå¦åˆ™è§†ä¸ºâ€œæ‹–æ‹½â€
                // è¿™æ ·å³ä½¿ä½ æŒ‰å¾—æ…¢ï¼Œä¹Ÿèƒ½æˆåŠŸæ·»åŠ è£…é¥°
                if (distance < 5) {
                    handleTreeClick(event);
                }
            });
        }

        function createTree() {
            treeGroup = new THREE.Group();
            treeGroup.name = "TreeGroup"; // æ–¹ä¾¿è°ƒè¯•

            // æ ‘å¹²
            const trunkGeo = new THREE.CylinderGeometry(2, 3, 10, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.9 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 5;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.name = 'trunk';
            treeGroup.add(trunk);

            // æ ‘å¶
            const levels = 5;
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x2d5a27, roughness: 0.8, flatShading: true 
            });

            for (let i = 0; i < levels; i++) {
                const sizeRatio = (levels - i) / levels;
                const height = 8;
                const radius = 12 * sizeRatio;
                const yPos = 10 + i * 5;

                const geometry = new THREE.ConeGeometry(radius, height, 16);
                const cone = new THREE.Mesh(geometry, material);
                cone.position.y = yPos;
                cone.castShadow = true;
                cone.receiveShadow = true;
                cone.rotation.y = Math.random() * Math.PI;
                
                cone.name = 'leaf'; // å…³é”®ï¼šç»™æ ‘å¶å‘½å
                treeGroup.add(cone);
            }

            // æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.IcosahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffea00 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 10 + levels * 5 - 2;
            star.name = 'star';
            treeGroup.add(star);

            // æ˜Ÿæ˜Ÿå…‰æ™•
            const starLight = new THREE.PointLight(0xffea00, 1, 20);
            starLight.position.copy(star.position);
            treeGroup.add(starLight);

            scene.add(treeGroup);
        }

        function handleTreeClick(event) {
            // è½¬æ¢é¼ æ ‡åæ ‡åˆ°å½’ä¸€åŒ–è®¾å¤‡åæ ‡ (-1 åˆ° +1)
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // æ£€æµ‹ treeGroup ä¸‹çš„æ‰€æœ‰å­ç‰©ä½“ (recursive: true)
            const intersects = raycaster.intersectObject(treeGroup, true);

            if (intersects.length > 0) {
                // è·å–ç¬¬ä¸€ä¸ªå‘½ä¸­çš„ç‰©ä½“
                const hit = intersects[0];

                // å¦‚æœç‚¹å‡»çš„æ˜¯ 'leaf' (ç»¿è‰²æ ‘å¶)
                if (hit.object.name === 'leaf') {
                    addDecoration(hit.point, hit.face.normal);
                }
            }
        }

        function addDecoration(point, normal) {
            let geometry, material;

            if (currentTool === 'ball') {
                geometry = new THREE.SphereGeometry(0.8, 16, 16);
                material = new THREE.MeshStandardMaterial({ 
                    color: Math.random() > 0.5 ? 0xff0000 : 0xffd700, 
                    metalness: 0.7, roughness: 0.2
                });
            } else if (currentTool === 'gold') {
                geometry = new THREE.CylinderGeometry(0.1, 0.8, 1, 8);
                material = new THREE.MeshStandardMaterial({ 
                    color: 0xffa500, metalness: 0.8, roughness: 0.3
                });
            } else if (currentTool === 'light') {
                geometry = new THREE.SphereGeometry(0.5, 8, 8);
                material = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1
                });
            }

            const mesh = new THREE.Mesh(geometry, material);
            
            // è®¾ç½®ä½ç½®
            mesh.position.copy(point);

            // ä¼˜åŒ–ï¼šæ²¿æ³•çº¿æ–¹å‘ç¨å¾®å‘å¤–åç§»ä¸€ç‚¹ç‚¹ï¼Œé˜²æ­¢è£…é¥°å“åŠä¸ªèº«å­åŸ‹åœ¨æ ‘é‡Œ
            mesh.position.add(normal.multiplyScalar(0.4));

            mesh.castShadow = true;
            scene.add(mesh);
            decorations.push(mesh);

            // ç®€å•çš„å¼¹è·³å‡ºç°åŠ¨ç”»
            mesh.scale.set(0,0,0);
            let s = 0;
            const animateSpawn = () => {
                s += 0.1;
                if (s <= 1.2) { // ç¨å¾®å¼¹å¤§ä¸€ç‚¹
                    mesh.scale.set(s,s,s);
                    requestAnimationFrame(animateSpawn);
                } else {
                    mesh.scale.set(1,1,1); // å›å½’æ­£å¸¸
                }
            };
            animateSpawn();
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(500, 500);
            const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1 });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createSnow() {
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    Math.random() * 200 - 100,
                    Math.random() * 100,
                    Math.random() * 200 - 100
                );
                velocities.push(
                    (Math.random() - 0.5) * 0.2, 
                    Math.random() * 0.2 + 0.1, 
                    (Math.random() - 0.5) * 0.2
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true, opacity: 0.8 });
            const snow = new THREE.Points(geometry, material);
            snow.userData = { velocities: velocities };
            scene.add(snow);
            scene.userData.snow = snow;
        }

        // UI å·¥å…·å‡½æ•°
        window.selectTool = function(tool, elem) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            elem.classList.add('active');
        };

        window.clearDecorations = function() {
            decorations.forEach(mesh => scene.remove(mesh));
            decorations = [];
        };

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.001;

            // æ˜Ÿæ˜Ÿè‡ªè½¬
            if (treeGroup) {
                treeGroup.children.forEach(child => {
                    if (child.name === 'star') {
                        child.rotation.y = time;
                    }
                });
            }

            // å‘¼å¸ç¯æ•ˆæœ
            if (currentTool === 'light') {
                decorations.forEach(d => {
                    if(d.material.emissive) {
                         d.material.emissiveIntensity = (Math.sin(time * 5 + d.id) + 1) * 0.5 + 0.5;
                    }
                });
            }

            // é›ªèŠ±é£˜è½
            const snow = scene.userData.snow;
            if (snow) {
                const positions = snow.geometry.attributes.position.array;
                const velocities = snow.userData.velocities;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 1] -= velocities[i * 3 + 1];
                    positions[i * 3] += Math.sin(time + i) * 0.05;
                    if (positions[i * 3 + 1] < 0) {
                        positions[i * 3 + 1] = 100;
                        positions[i * 3] = (Math.random() * 200 - 100);
                        positions[i * 3 + 2] = (Math.random() * 200 - 100);
                    }
                }
                snow.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>