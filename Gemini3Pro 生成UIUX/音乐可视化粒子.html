<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3D Audio Visualizer Particles</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }
        canvas { display: block; }
        
        /* 交互 UI 样式 */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.8);
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        .btn-container {
            text-align: center;
            padding: 40px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        h1 { font-weight: 300; letter-spacing: 5px; text-transform: uppercase; font-size: 24px; margin-bottom: 20px;}
        p { font-size: 14px; color: #aaa; margin-bottom: 30px; }

        /* 文件上传按钮美化 */
        .upload-btn-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .btn {
            border: 2px solid #00ffff;
            color: #00ffff;
            background-color: transparent;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
        }

        .btn:hover {
            background-color: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }

        .upload-btn-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        #status {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            font-size: 12px;
            color: #555;
        }
    </style>
</head>
<body>

    <!-- 启动/上传界面 -->
    <div id="overlay">
        <div class="btn-container">
            <h1>Particle Visualizer</h1>
            <p>上传 MP3 文件以开始可视化体验</p>
            
            <div class="upload-btn-wrapper">
                <button class="btn">选择音乐</button>
                <input type="file" id="fileInput" accept="audio/*" />
            </div>
        </div>
    </div>

    <div id="status">鼠标移动控制视角 | 音乐控制波浪</div>

    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer;
        let particles, particleGeo, material;
        let count = 6000; 

        // 鼠标交互
        let mouseX = 0, mouseY = 0;
        let targetX = 0, targetY = 0;
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        // 音频相关变量
        let sound, analyser;
        let isPlaying = false;
        let dataArray; // 存储音频频率数据

        init();
        animate();

        function init() {
            // 1. 场景与摄像机
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.0015); // 增加一点雾气

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 4000);
            camera.position.z = 1200;
            camera.position.y = 200;

            // 2. 粒子几何体
            particleGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3); // 为每个粒子添加颜色属性

            let i = 0;
            const color = new THREE.Color();

            for (let ix = 0; ix < count; ix++) {
                // 扩展分布范围，使其更宽阔
                positions[i] = (Math.random() * 2 - 1) * 1500;
                positions[i + 1] = (Math.random() * 2 - 1) * 500; // Y轴初始扁一点
                positions[i + 2] = (Math.random() * 2 - 1) * 1500;

                // 初始颜色：青色
                color.setHSL(0.5, 1.0, 0.5);
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;

                i += 3;
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // 3. 材质 (开启 vertexColors 以便单独控制粒子颜色)
            material = new THREE.PointsMaterial({
                size: 4,
                vertexColors: true, // 关键：开启顶点颜色
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending // 发光混合模式
            });

            particles = new THREE.Points(particleGeo, material);
            scene.add(particles);

            // 4. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 5. 事件
            document.addEventListener('mousemove', onDocumentMouseMove);
            window.addEventListener('resize', onWindowResize);
            
            // 绑定文件上传事件
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        }

        // 处理音频上传
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                initAudio(e.target.result); // 将文件数据传给音频初始化函数
                
                // 隐藏 UI
                const overlay = document.getElementById('overlay');
                overlay.style.opacity = 0;
                setTimeout(() => overlay.style.display = 'none', 500);
            };
            reader.readAsArrayBuffer(file);
        }

        // 初始化音频系统
        function initAudio(arrayBuffer) {
            const listener = new THREE.AudioListener();
            camera.add(listener);

            sound = new THREE.Audio(listener);
            const audioLoader = new THREE.AudioLoader();
            
            // 解析音频数据
            const context = listener.context;
            context.decodeAudioData(arrayBuffer, function(buffer) {
                sound.setBuffer(buffer);
                sound.setLoop(true);
                sound.setVolume(0.5);
                sound.play();
                isPlaying = true;

                // 创建分析器 (fftSize 决定了数据的精细度，必须是2的幂)
                analyser = new THREE.AudioAnalyser(sound, 128); 
            });
        }

        function onDocumentMouseMove(event) {
            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            const time = Date.now() * 0.0001;

            // 获取音频数据
            let avgFreq = 0;
            let highFreq = 0; // 高频分量
            
            if (isPlaying && analyser) {
                // 获取平均频率 (0 - 255)
                avgFreq = analyser.getAverageFrequency(); 
                
                // 获取详细频率数据来分析高音
                dataArray = analyser.getFrequencyData();
                const halfLength = Math.floor(dataArray.length / 2);
                // 简单取后半段作为高音参考
                for(let k=halfLength; k<dataArray.length; k++) {
                    highFreq += dataArray[k];
                }
                highFreq = highFreq / halfLength;
            }

            // 交互平滑逻辑
            targetX = mouseX * 0.0005;
            targetY = mouseY * 0.0005;

            // 基础旋转 + 音乐带来的额外旋转 (音乐越响，转得越快)
            particles.rotation.y += 0.002 + (avgFreq * 0.0001); 
            particles.rotation.x += 0.05 * (targetY - particles.rotation.x);
            particles.rotation.z += 0.05 * (targetX - particles.rotation.z);

            // 粒子波动逻辑
            const positions = particleGeo.attributes.position.array;
            const colors = particleGeo.attributes.color.array;
            const tempColor = new THREE.Color();

            for (let i = 0; i < count; i++) {
                const px = positions[i * 3];
                const pz = positions[i * 3 + 2];

                // --- 核心：音乐可视化算法 ---
                
                // 1. 计算波浪幅度 (基础幅度 + 音乐幅度)
                // avgFreq 通常在 0-150 之间，除以系数来控制缩放
                const waveHeight = 50 + (avgFreq * 2.5); 

                // 2. 更新 Y 轴位置
                // 使用正弦波，但频率受音乐影响略微扰动
                positions[i * 3 + 1] = (Math.sin((px * 0.005) + (time * 20)) * waveHeight) + 
                                       (Math.cos((pz * 0.003) + (time * 10)) * waveHeight);

                // 3. 动态颜色
                // 如果正在播放，根据位置和高音强度改变颜色
                if (isPlaying) {
                    // 基础色调 (Hue)
                    // 在 0.5 (青色) 和 0.8 (紫色) 之间变化
                    // 根据粒子在Y轴的高度混入颜色变化
                    const heightFactor = (positions[i*3+1] + 200) / 400; 
                    
                    // 当高音强时，颜色向红色偏移
                    const hue = 0.5 + (highFreq * 0.003) + (heightFactor * 0.1);
                    
                    // 亮度也随音乐跳动
                    const lightness = 0.3 + (avgFreq * 0.002);

                    tempColor.setHSL(hue % 1, 0.8, lightness);
                    
                    colors[i * 3] = tempColor.r;
                    colors[i * 3 + 1] = tempColor.g;
                    colors[i * 3 + 2] = tempColor.b;
                }
            }

            particleGeo.attributes.position.needsUpdate = true;
            particleGeo.attributes.color.needsUpdate = true;

            // 摄像机轻微缩放 (Base kick effect)
            // 当低音很重时(avgFreq > 100)，摄像机稍微拉近
            if(avgFreq > 100) {
               camera.position.z = 1200 - (avgFreq * 0.5);
            } else {
                // 平滑复位
                if (camera.position.z < 1200) camera.position.z += 1;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>